 Makefile                |    3 +-
 common/common.c         |    3 +-
 common/osdep.h          |    3 +-
 encoder/encoder.c       |    5 +-
 encoder/ratecontrol.c   |   11 +--
 input/avs.c             |   19 ++++-
 input/ffms.c            |   29 ++++++-
 input/raw.c             |    3 +-
 input/timecode.c        |    3 +-
 input/y4m.c             |    3 +-
 output/flv_bytestream.c |    3 +-
 output/matroska_ebml.c  |    3 +-
 output/mp4.c            |   27 +++++-
 output/raw.c            |    3 +-
 tools/xyuv.c            |    3 +-
 unicode_support.c       |  216 +++++++++++++++++++++++++++++++++++++++++++++++
 unicode_support.h       |   36 ++++++++
 x264.c                  |   33 +++++++-
 18 files changed, 377 insertions(+), 29 deletions(-)

diff --git a/Makefile b/Makefile
index 7a22c42..2299634 100644
--- a/Makefile
+++ b/Makefile
@@ -18,7 +18,8 @@ SRCS = common/mc.c common/predict.c common/pixel.c common/macroblock.c \
        common/mvpred.c common/bitstream.c \
        encoder/analyse.c encoder/me.c encoder/ratecontrol.c \
        encoder/set.c encoder/macroblock.c encoder/cabac.c \
-       encoder/cavlc.c encoder/encoder.c encoder/lookahead.c
+       encoder/cavlc.c encoder/encoder.c encoder/lookahead.c \
+       unicode_support.c
 
 SRCCLI = x264.c input/input.c input/timecode.c input/raw.c input/y4m.c \
          output/raw.c output/matroska.c output/matroska_ebml.c \
diff --git a/common/common.c b/common/common.c
index 3f40e66..bb11faa 100644
--- a/common/common.c
+++ b/common/common.c
@@ -25,6 +25,7 @@
  *****************************************************************************/
 
 #include "common.h"
+#include "unicode_support.h"
 
 #include <stdarg.h>
 #include <ctype.h>
@@ -1225,7 +1226,7 @@ char *x264_slurp_file( const char *filename )
     int b_error = 0;
     size_t i_size;
     char *buf;
-    FILE *fh = fopen( filename, "rb" );
+    FILE *fh = fopen_utf8( filename, "rb" );
     if( !fh )
         return NULL;
     b_error |= fseek( fh, 0, SEEK_END ) < 0;
diff --git a/common/osdep.h b/common/osdep.h
index f7cad57..41af502 100644
--- a/common/osdep.h
+++ b/common/osdep.h
@@ -34,6 +34,7 @@
 #include <inttypes.h>
 
 #include "config.h"
+#include "unicode_support.h"
 
 #if !HAVE_LOG2F
 #define log2f(x) (logf(x)/0.693147180559945f)
@@ -329,7 +330,7 @@ static inline uint8_t x264_is_regular_file( FILE *filehandle )
 static inline uint8_t x264_is_regular_file_path( const char *filename )
 {
     struct stat file_stat;
-    if( stat( filename, &file_stat ) )
+    if( stat_utf8( filename, &file_stat ) )
         return -1;
     return S_ISREG( file_stat.st_mode );
 }
diff --git a/encoder/encoder.c b/encoder/encoder.c
index 104df1a..93c4049 100644
--- a/encoder/encoder.c
+++ b/encoder/encoder.c
@@ -32,6 +32,7 @@
 #include "ratecontrol.h"
 #include "macroblock.h"
 #include "me.h"
+#include "unicode_support.h"
 
 #if HAVE_VISUALIZE
 #include "common/visualize.h"
@@ -82,7 +83,7 @@ static int x264_threadpool_wait_all( x264_t *h )
 
 static void x264_frame_dump( x264_t *h )
 {
-    FILE *f = fopen( h->param.psz_dump_yuv, "r+b" );
+    FILE *f = fopen_utf8( h->param.psz_dump_yuv, "r+b" );
     if( !f )
         return;
 
@@ -1347,7 +1348,7 @@ x264_t *x264_encoder_open( x264_param_t *param )
     if( h->param.psz_dump_yuv )
     {
         /* create or truncate the reconstructed video file */
-        FILE *f = fopen( h->param.psz_dump_yuv, "w" );
+        FILE *f = fopen_utf8( h->param.psz_dump_yuv, "w" );
         if( !f )
         {
             x264_log( h, X264_LOG_ERROR, "dump_yuv: can't write to %s\n", h->param.psz_dump_yuv );
diff --git a/encoder/ratecontrol.c b/encoder/ratecontrol.c
index 0437fbd..039ffec 100644
--- a/encoder/ratecontrol.c
+++ b/encoder/ratecontrol.c
@@ -33,6 +33,7 @@
 #include "common/common.h"
 #include "ratecontrol.h"
 #include "me.h"
+#include "unicode_support.h"
 
 typedef struct
 {
@@ -728,7 +729,7 @@ int x264_ratecontrol_new( x264_t *h )
             char *mbtree_stats_in = x264_strcat_filename( h->param.rc.psz_stat_in, ".mbtree" );
             if( !mbtree_stats_in )
                 return -1;
-            rc->p_mbtree_stat_file_in = fopen( mbtree_stats_in, "rb" );
+            rc->p_mbtree_stat_file_in = fopen_utf8( mbtree_stats_in, "rb" );
             x264_free( mbtree_stats_in );
             if( !rc->p_mbtree_stat_file_in )
             {
@@ -993,7 +994,7 @@ parse_error:
         if( !rc->psz_stat_file_tmpname )
             return -1;
 
-        rc->p_stat_file_out = fopen( rc->psz_stat_file_tmpname, "wb" );
+        rc->p_stat_file_out = fopen_utf8( rc->psz_stat_file_tmpname, "wb" );
         if( rc->p_stat_file_out == NULL )
         {
             x264_log( h, X264_LOG_ERROR, "ratecontrol_init: can't open stats file\n" );
@@ -1011,7 +1012,7 @@ parse_error:
             if( !rc->psz_mbtree_stat_file_tmpname || !rc->psz_mbtree_stat_file_name )
                 return -1;
 
-            rc->p_mbtree_stat_file_out = fopen( rc->psz_mbtree_stat_file_tmpname, "wb" );
+            rc->p_mbtree_stat_file_out = fopen_utf8( rc->psz_mbtree_stat_file_tmpname, "wb" );
             if( rc->p_mbtree_stat_file_out == NULL )
             {
                 x264_log( h, X264_LOG_ERROR, "ratecontrol_init: can't open mbtree stats file\n" );
@@ -1188,7 +1189,7 @@ void x264_ratecontrol_delete( x264_t *h )
         b_regular_file = x264_is_regular_file( rc->p_stat_file_out );
         fclose( rc->p_stat_file_out );
         if( h->i_frame >= rc->num_entries && b_regular_file )
-            if( rename( rc->psz_stat_file_tmpname, h->param.rc.psz_stat_out ) != 0 )
+            if( rename_utf8( rc->psz_stat_file_tmpname, h->param.rc.psz_stat_out ) != 0 )
             {
                 x264_log( h, X264_LOG_ERROR, "failed to rename \"%s\" to \"%s\"\n",
                           rc->psz_stat_file_tmpname, h->param.rc.psz_stat_out );
@@ -1200,7 +1201,7 @@ void x264_ratecontrol_delete( x264_t *h )
         b_regular_file = x264_is_regular_file( rc->p_mbtree_stat_file_out );
         fclose( rc->p_mbtree_stat_file_out );
         if( h->i_frame >= rc->num_entries && b_regular_file )
-            if( rename( rc->psz_mbtree_stat_file_tmpname, rc->psz_mbtree_stat_file_name ) != 0 )
+            if( rename_utf8( rc->psz_mbtree_stat_file_tmpname, rc->psz_mbtree_stat_file_name ) != 0 )
             {
                 x264_log( h, X264_LOG_ERROR, "failed to rename \"%s\" to \"%s\"\n",
                           rc->psz_mbtree_stat_file_tmpname, rc->psz_mbtree_stat_file_name );
diff --git a/input/avs.c b/input/avs.c
index bf4d39a..7f35f4f 100644
--- a/input/avs.c
+++ b/input/avs.c
@@ -26,6 +26,7 @@
 #include "input.h"
 #include <windows.h>
 #define FAIL_IF_ERROR( cond, ... ) FAIL_IF_ERR( cond, "avs", __VA_ARGS__ )
+#define MAX_PATH_UTF8 (MAX_PATH * 4)
 
 #define AVSC_NO_DECLSPEC
 #undef EXTERN_C
@@ -40,6 +41,8 @@
 #include <libavutil/pixfmt.h>
 #endif
 
+#include "unicode_support.h"
+
 /* maximum size of the sequence of filters to try on non script files */
 #define AVS_MAX_SEQUENCE 5
 
@@ -132,14 +135,26 @@ static float get_avs_version( avs_hnd_t *h )
     return ret;
 }
 
-static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
+static int open_file( char *psz_filename_utf8, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
 {
-    FILE *fh = fopen( psz_filename, "r" );
+    char psz_filename[MAX_PATH_UTF8];
+    x264_strncpy(psz_filename, psz_filename_utf8, MAX_PATH_UTF8);
+
+    FILE *fh = fopen_utf8( psz_filename_utf8, "r" );
     if( !fh )
         return -1;
     FAIL_IF_ERROR( !x264_is_regular_file( fh ), "AVS input is incompatible with non-regular file `%s'\n", psz_filename );
     fclose( fh );
 
+    /* Avisynth can't handle Unicode at all, so we will convert the path to ANSI */
+    char *short_path = path_utf8_to_ansi(psz_filename_utf8, FALSE);
+    if( short_path )
+    {
+        x264_strncpy(psz_filename, short_path, MAX_PATH_UTF8);
+        free(short_path); short_path = NULL;
+    }
+    x264_cli_log( "avs", X264_LOG_INFO, "Source: %s\n", psz_filename );
+
     avs_hnd_t *h = malloc( sizeof(avs_hnd_t) );
     if( !h )
         return -1;
diff --git a/input/ffms.c b/input/ffms.c
index 03d786e..e49e098 100644
--- a/input/ffms.c
+++ b/input/ffms.c
@@ -36,8 +36,11 @@
 #include <windows.h>
 #else
 #define SetConsoleTitle(t)
+#define MAX_PATH 260
 #endif
 
+#define MAX_PATH_UTF8 (MAX_PATH * 4)
+
 typedef struct
 {
     FFMS_VideoSource *video_source;
@@ -79,10 +82,28 @@ static int handle_jpeg( int csp, int *fullrange )
 
 static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
 {
+    char index_file_ansi[MAX_PATH_UTF8];
+    x264_strncpy(index_file_ansi, opt->index_file, MAX_PATH_UTF8);
+
     ffms_hnd_t *h = calloc( 1, sizeof(ffms_hnd_t) );
     if( !h )
         return -1;
+
+#ifdef _WIN32
+    FFMS_Init( 0, 1 );
+#ifdef __MINGW32__
+    /*FFMS2 UTF-8 support is broken for the index file on MinGW*/
+    char *temp = path_utf8_to_ansi(opt->index_file, TRUE);
+    if( temp )
+    {
+        x264_strncpy(index_file_ansi, temp, MAX_PATH_UTF8);
+        free(temp); temp = NULL;
+    }
+#endif
+#else
     FFMS_Init( 0, 0 );
+#endif
+
     FFMS_ErrorInfo e;
     e.BufferSize = 0;
     int seekmode = opt->seek ? FFMS_SEEK_NORMAL : FFMS_SEEK_LINEAR_NO_RW;
@@ -91,9 +112,9 @@ static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, c
     if( opt->index_file )
     {
         struct stat index_s, input_s;
-        if( !stat( opt->index_file, &index_s ) && !stat( psz_filename, &input_s ) &&
-            input_s.st_mtime < index_s.st_mtime )
-            idx = FFMS_ReadIndex( opt->index_file, &e );
+        if( !stat_utf8( opt->index_file, &index_s ) && !stat_utf8( psz_filename, &input_s ) &&
+            input_s.st_mtime < index_s.st_mtime && index_s.st_size > 16)
+            idx = FFMS_ReadIndex( index_file_ansi, &e );
     }
     if( !idx )
     {
@@ -105,7 +126,7 @@ static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, c
         else
             idx = FFMS_MakeIndex( psz_filename, 0, 0, NULL, NULL, 0, NULL, NULL, &e );
         FAIL_IF_ERROR( !idx, "could not create index\n" )
-        if( opt->index_file && FFMS_WriteIndex( opt->index_file, idx, &e ) )
+        if( opt->index_file && FFMS_WriteIndex( index_file_ansi, idx, &e ) )
             x264_cli_log( "ffms", X264_LOG_WARNING, "could not write index file\n" );
     }
 
diff --git a/input/raw.c b/input/raw.c
index a9b2de1..62bab90 100644
--- a/input/raw.c
+++ b/input/raw.c
@@ -27,6 +27,7 @@
 
 #include "input.h"
 #define FAIL_IF_ERROR( cond, ... ) FAIL_IF_ERR( cond, "raw", __VA_ARGS__ )
+#include "unicode_support.h"
 
 typedef struct
 {
@@ -70,7 +71,7 @@ static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, c
     if( !strcmp( psz_filename, "-" ) )
         h->fh = stdin;
     else
-        h->fh = fopen( psz_filename, "rb" );
+        h->fh = fopen_utf8( psz_filename, "rb" );
     if( h->fh == NULL )
         return -1;
 
diff --git a/input/timecode.c b/input/timecode.c
index f7da8fb..6df66a1 100644
--- a/input/timecode.c
+++ b/input/timecode.c
@@ -25,6 +25,7 @@
 
 #include "input.h"
 #define FAIL_IF_ERROR( cond, ... ) FAIL_IF_ERR( cond, "timecode", __VA_ARGS__ )
+#include "unicode_support.h"
 
 typedef struct
 {
@@ -368,7 +369,7 @@ static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, c
     timecode_input.picture_alloc = h->input.picture_alloc;
     timecode_input.picture_clean = h->input.picture_clean;
 
-    tcfile_in = fopen( psz_filename, "rb" );
+    tcfile_in = fopen_utf8( psz_filename, "rb" );
     FAIL_IF_ERROR( !tcfile_in, "can't open `%s'\n", psz_filename )
     else if( !x264_is_regular_file( tcfile_in ) )
     {
diff --git a/input/y4m.c b/input/y4m.c
index 6f37b0e..68eda91 100644
--- a/input/y4m.c
+++ b/input/y4m.c
@@ -26,6 +26,7 @@
 
 #include "input.h"
 #define FAIL_IF_ERROR( cond, ... ) FAIL_IF_ERR( cond, "y4m", __VA_ARGS__ )
+#include "unicode_support.h"
 
 typedef struct
 {
@@ -72,7 +73,7 @@ static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, c
     if( !strcmp( psz_filename, "-" ) )
         h->fh = stdin;
     else
-        h->fh = fopen(psz_filename, "rb");
+        h->fh = fopen_utf8(psz_filename, "rb");
     if( h->fh == NULL )
         return -1;
 
diff --git a/output/flv_bytestream.c b/output/flv_bytestream.c
index 57d40da..836804d 100644
--- a/output/flv_bytestream.c
+++ b/output/flv_bytestream.c
@@ -25,6 +25,7 @@
 
 #include "output.h"
 #include "flv_bytestream.h"
+#include "unicode_support.h"
 
 uint64_t flv_dbl2int( double value )
 {
@@ -96,7 +97,7 @@ flv_buffer *flv_create_writer( const char *filename )
     if( !strcmp( filename, "-" ) )
         c->fp = stdout;
     else
-        c->fp = fopen( filename, "wb" );
+        c->fp = fopen_utf8( filename, "wb" );
     if( !c->fp )
     {
         free( c );
diff --git a/output/matroska_ebml.c b/output/matroska_ebml.c
index f58d47d..db6e8ff 100644
--- a/output/matroska_ebml.c
+++ b/output/matroska_ebml.c
@@ -25,6 +25,7 @@
 
 #include "output.h"
 #include "matroska_ebml.h"
+#include "unicode_support.h"
 
 #define CLSIZE 1048576
 #define CHECK(x)\
@@ -307,7 +308,7 @@ mk_writer *mk_create_writer( const char *filename )
     if( !strcmp( filename, "-" ) )
         w->fp = stdout;
     else
-        w->fp = fopen( filename, "wb" );
+        w->fp = fopen_utf8( filename, "wb" );
     if( !w->fp )
     {
         mk_destroy_contexts( w );
diff --git a/output/mp4.c b/output/mp4.c
index 7f12365..cef01c4 100644
--- a/output/mp4.c
+++ b/output/mp4.c
@@ -25,6 +25,7 @@
  *****************************************************************************/
 
 #include "output.h"
+#include "unicode_support.h"
 #include <gpac/isomedia.h>
 
 #if HAVE_GF_MALLOC
@@ -36,6 +37,14 @@
 #define realloc gf_realloc
 #endif
 
+#ifdef _WIN32
+#include <windows.h>
+#else
+#define MAX_PATH 260
+#endif
+
+#define MAX_PATH_UTF8 (MAX_PATH * 4)
+
 typedef struct
 {
     GF_ISOFile *p_file;
@@ -168,17 +177,31 @@ static int close_file( hnd_t handle, int64_t largest_pts, int64_t second_largest
     return 0;
 }
 
-static int open_file( char *psz_filename, hnd_t *p_handle, cli_output_opt_t *opt )
+static int open_file( char *psz_filename_utf8, hnd_t *p_handle, cli_output_opt_t *opt )
 {
+    char psz_filename[MAX_PATH_UTF8];
+    x264_strncpy(psz_filename, psz_filename_utf8, MAX_PATH_UTF8);
+
     mp4_hnd_t *p_mp4;
 
     *p_handle = NULL;
-    FILE *fh = fopen( psz_filename, "w" );
+    FILE *fh = fopen_utf8( psz_filename_utf8, "w" );
     if( !fh )
         return -1;
     FAIL_IF_ERR( !x264_is_regular_file( fh ), "mp4", "MP4 output is incompatible with non-regular file `%s'\n", psz_filename )
     fclose( fh );
 
+#ifdef _WIN32
+    /* GPAC can't handle Unicode at all, so we will convert the path to ANSI */
+    char *short_path = path_utf8_to_ansi(psz_filename_utf8, TRUE);
+    if( short_path )
+    {
+        x264_strncpy(psz_filename, short_path, MAX_PATH_UTF8);
+        free(short_path); short_path = NULL;
+    }
+    x264_cli_log( "mp4", X264_LOG_INFO, "Output: %s\n", psz_filename );
+#endif //_WIN32
+
     if( !(p_mp4 = malloc( sizeof(mp4_hnd_t) )) )
         return -1;
 
diff --git a/output/raw.c b/output/raw.c
index ed3174c..085b4d7 100644
--- a/output/raw.c
+++ b/output/raw.c
@@ -25,12 +25,13 @@
  *****************************************************************************/
 
 #include "output.h"
+#include "unicode_support.h"
 
 static int open_file( char *psz_filename, hnd_t *p_handle, cli_output_opt_t *opt )
 {
     if( !strcmp( psz_filename, "-" ) )
         *p_handle = stdout;
-    else if( !(*p_handle = fopen( psz_filename, "w+b" )) )
+    else if( !(*p_handle = fopen_utf8( psz_filename, "w+b" )) )
         return -1;
 
     return 0;
diff --git a/tools/xyuv.c b/tools/xyuv.c
index 8e80632..5494ab9 100644
--- a/tools/xyuv.c
+++ b/tools/xyuv.c
@@ -22,6 +22,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdint.h>
+#include "unicode_support.h"
 
 #include <SDL/SDL.h>
 
@@ -166,7 +167,7 @@ int main( int argc, char **argv )
         } else if( !strcmp( argv[i], "-g" ) || !strcasecmp( argv[i], "--grid" ) ) {
             xyuv.b_grid = 1;
         } else {
-            FILE *f = fopen( argv[i], "rb" );
+            FILE *f = fopen_utf8( argv[i], "rb" );
             if( !f ) {
                 fprintf( stderr, "cannot open YUV %s\n", argv[i] );
             } else {
diff --git a/unicode_support.c b/unicode_support.c
new file mode 100644
index 0000000..8dd3537
--- /dev/null
+++ b/unicode_support.c
@@ -0,0 +1,216 @@
+#include "unicode_support.h"
+
+#ifdef _WIN32
+
+#include <windows.h>
+#include <sys/stat.h>
+
+char *utf16_to_utf8(const wchar_t *input)
+{
+	char *Buffer;
+	int BuffSize = 0, Result = 0;
+
+	BuffSize = WideCharToMultiByte(CP_UTF8, 0, input, -1, NULL, 0, NULL, NULL);
+	Buffer = (char*) malloc(sizeof(char) * BuffSize);
+	if(Buffer)
+	{
+		Result = WideCharToMultiByte(CP_UTF8, 0, input, -1, Buffer, BuffSize, NULL, NULL);
+	}
+
+	return ((Result > 0) && (Result <= BuffSize)) ? Buffer : NULL;
+}
+
+char *utf16_to_ansi(const wchar_t *input)
+{
+	char *Buffer;
+	int BuffSize = 0, Result = 0;
+
+	BuffSize = WideCharToMultiByte(CP_ACP, 0, input, -1, NULL, 0, NULL, NULL);
+	Buffer = (char*) malloc(sizeof(char) * BuffSize);
+	if(Buffer)
+	{
+		Result = WideCharToMultiByte(CP_ACP, 0, input, -1, Buffer, BuffSize, NULL, NULL);
+	}
+
+	return ((Result > 0) && (Result <= BuffSize)) ? Buffer : NULL;
+}
+
+wchar_t *utf8_to_utf16(const char *input)
+{
+	wchar_t *Buffer;
+	int BuffSize = 0, Result = 0;
+
+	BuffSize = MultiByteToWideChar(CP_UTF8, 0, input, -1, NULL, 0);
+	Buffer = (wchar_t*) malloc(sizeof(wchar_t) * BuffSize);
+	if(Buffer)
+	{
+		Result = MultiByteToWideChar(CP_UTF8, 0, input, -1, Buffer, BuffSize);
+	}
+
+	return ((Result > 0) && (Result <= BuffSize)) ? Buffer : NULL;
+}
+
+void init_commandline_arguments_utf8(int *argc, char ***argv)
+{
+	int i, nArgs;
+	LPWSTR *szArglist;
+
+	szArglist = CommandLineToArgvW(GetCommandLineW(), &nArgs);
+
+	if(NULL == szArglist)
+	{
+		fprintf(stderr, "\nFATAL: CommandLineToArgvW failed\n\n");
+		exit(-1);
+	}
+
+	*argv = malloc(sizeof(char*) * nArgs);
+	*argc = nArgs;
+
+	if(NULL == *argv)
+	{
+		fprintf(stderr, "\nFATAL: Malloc failed\n\n");
+		exit(-1);
+	}
+	
+	for(i = 0; i < nArgs; i++)
+	{
+		(*argv)[i] = utf16_to_utf8(szArglist[i]);
+		if(NULL == (*argv)[i])
+		{
+			fprintf(stderr, "\nFATAL: utf16_to_utf8 failed\n\n");
+			exit(-1);
+		}
+	}
+
+	LocalFree(szArglist);
+}
+
+void free_commandline_arguments_utf8(int *argc, char ***argv)
+{
+	int i = 0;
+	
+	if(*argv != NULL)
+	{
+		for(i = 0; i < *argc; i++)
+		{
+			if((*argv)[i] != NULL)
+			{
+				free((*argv)[i]);
+				(*argv)[i] = NULL;
+			}
+		}
+		free(*argv);
+		*argv = NULL;
+	}
+}
+
+FILE *fopen_utf8(const char *filename_utf8, const char *mode_utf8)
+{
+	FILE *ret = NULL;
+	wchar_t *filename_utf16 = utf8_to_utf16(filename_utf8);
+	wchar_t *mode_utf16 = utf8_to_utf16(mode_utf8);
+	
+	if(filename_utf16 && mode_utf16)
+	{
+		ret = _wfopen(filename_utf16, mode_utf16);
+	}
+
+	if(filename_utf16) free(filename_utf16);
+	if(mode_utf16) free(mode_utf16);
+
+	return ret;
+}
+
+int stat_utf8(const char *path_utf8, struct stat *buf)
+{
+	int ret = -1;
+	
+	wchar_t *path_utf16 = utf8_to_utf16(path_utf8);
+	if(path_utf16)
+	{
+		ret = wstat(path_utf16, buf);
+		free(path_utf16);
+	}
+	
+	return ret;
+}
+
+int rename_utf8(const char *oldname_utf8, const char *newname_utf8)
+{
+	int ret = -1;
+	
+	wchar_t *oldname_utf16 = utf8_to_utf16(oldname_utf8);
+	wchar_t *newname_utf16 = utf8_to_utf16(newname_utf8);
+	
+	if(oldname_utf16 && newname_utf16)
+	{
+		_wunlink(newname_utf16);
+		ret = _wrename(oldname_utf16, newname_utf16);
+	}
+
+	if(newname_utf16) free(newname_utf16);
+	if(oldname_utf16) free(oldname_utf16);
+
+	return ret;
+}
+
+char *path_utf8_to_ansi(const char *psz_filename_utf8, int b_create)
+{
+	if(!psz_filename_utf8)
+	{
+		return NULL;
+	}
+	
+	char *short_path = NULL;
+	
+	wchar_t *psz_filename_utf16 = utf8_to_utf16(psz_filename_utf8);
+	if(psz_filename_utf16)
+	{
+		if(b_create)
+		{
+			FILE *fh = _wfopen(psz_filename_utf16, L"a+");
+			if(fh) fclose(fh);
+		}
+		char *psz_filename_ansi = utf16_to_ansi(psz_filename_utf16);
+		if(psz_filename_ansi)
+		{
+			if(strcmp(psz_filename_ansi, psz_filename_utf8))
+			{
+				wchar_t short_name_utf16[MAX_PATH];
+				DWORD result = GetShortPathNameW(psz_filename_utf16, short_name_utf16, MAX_PATH);
+				if((result > 0) && (result < MAX_PATH))
+				{
+					short_path = utf16_to_ansi(short_name_utf16);
+					free(psz_filename_ansi);
+				}
+				else
+				{
+					short_path = psz_filename_ansi; /*if GetShortPathName() failed, use the ANSI version*/
+				}
+			}
+			else
+			{
+				short_path = psz_filename_ansi; /*don't convert plain ASCII filenames to "short" path*/
+			}
+		}
+		free(psz_filename_utf16);
+	}
+
+	return short_path;
+}
+
+#endif //_WIN32
+
+char *x264_strncpy(char *destination, const char *source, size_t num)
+{
+	char *ret = destination;
+	memset(destination, 0, num);
+	
+	if(source)
+	{
+		ret = strncpy(destination, source, num);
+		destination[num-1] = '\0';
+	}
+	
+	return ret;
+}
diff --git a/unicode_support.h b/unicode_support.h
new file mode 100644
index 0000000..9cc82c2
--- /dev/null
+++ b/unicode_support.h
@@ -0,0 +1,36 @@
+#ifndef UNICODE_SUPPORT_H_INCLUDED
+#define UNICODE_SUPPORT_H_INCLUDED
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef _WIN32
+#ifndef _INC_STAT
+struct stat;
+#endif
+char *utf16_to_utf8(const wchar_t *input);
+char *utf16_to_ansi(const wchar_t *input);
+wchar_t *utf8_to_utf16(const char *input);
+void init_commandline_arguments_utf8(int *argc, char ***argv);
+void free_commandline_arguments_utf8(int *argc, char ***argv);
+FILE *fopen_utf8(const char *filename_utf8, const char *mode_utf8);
+int stat_utf8(const char *path_utf8, struct stat *buf);
+int rename_utf8(const char *oldname_utf8, const char *newname_utf8);
+char *path_utf8_to_ansi(const char *psz_filename_utf8, int b_create);
+#else
+#define fopen_utf8(NAME, MODE) fopen(NAME, MODE)
+#define stat_utf8(PATH, BUF) stat(PATH, BUF)
+#define rename_utf8(OLD, NEW) rename(OLD, NEW)
+#endif
+
+char *x264_strncpy (char *destination, const char *source, size_t num);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
\ No newline at end of file
diff --git a/x264.c b/x264.c
index 5519810..23cf904 100644
--- a/x264.c
+++ b/x264.c
@@ -35,6 +35,7 @@
 #include "input/input.h"
 #include "output/output.h"
 #include "filters/filters.h"
+#include "unicode_support.h"
 
 #define FAIL_IF_ERROR( cond, ... ) FAIL_IF_ERR( cond, "x264", __VA_ARGS__ )
 
@@ -266,7 +267,7 @@ static void print_version_info()
 #endif
 }
 
-int main( int argc, char **argv )
+static int x264_main( int argc, char **argv )
 {
     x264_param_t param;
     cli_opt_t opt = {0};
@@ -1078,7 +1079,7 @@ static int select_input( const char *demuxer, char *used_demuxer, char *filename
     b_regular = b_regular && x264_is_regular_file_path( filename );
     if( b_regular )
     {
-        FILE *f = fopen( filename, "r" );
+        FILE *f = fopen_utf8( filename, "r" );
         if( f )
         {
             b_regular = x264_is_regular_file( f );
@@ -1322,7 +1323,7 @@ static int parse( int argc, char **argv, x264_param_t *param, cli_opt_t *opt )
                 input_opt.index_file = optarg;
                 break;
             case OPT_QPFILE:
-                opt->qpfile = fopen( optarg, "rb" );
+                opt->qpfile = fopen_utf8( optarg, "rb" );
                 FAIL_IF_ERROR( !opt->qpfile, "can't open qpfile `%s'\n", optarg )
                 if( !x264_is_regular_file( opt->qpfile ) )
                 {
@@ -1381,7 +1382,7 @@ static int parse( int argc, char **argv, x264_param_t *param, cli_opt_t *opt )
                 tcfile_name = optarg;
                 break;
             case OPT_TCFILE_OUT:
-                opt->tcfile_out = fopen( optarg, "wb" );
+                opt->tcfile_out = fopen_utf8( optarg, "wb" );
                 FAIL_IF_ERROR( !opt->tcfile_out, "can't open `%s'\n", optarg )
                 break;
             case OPT_TIMEBASE:
@@ -1917,3 +1918,27 @@ fail:
 
     return retval;
 }
+
+#ifdef _WIN32
+int main( int argc, char **argv )
+{
+  int x264_argc;
+  char **x264_argv;
+  int exit_code;
+
+  UINT old_cp = GetConsoleOutputCP();
+  SetConsoleOutputCP(CP_UTF8);
+
+  init_commandline_arguments_utf8(&x264_argc, &x264_argv);
+  exit_code = x264_main(x264_argc, x264_argv);
+  free_commandline_arguments_utf8(&x264_argc, &x264_argv);
+
+  SetConsoleOutputCP(old_cp);
+  return exit_code;
+}
+#else
+int main( int argc, char **argv )
+{
+    return x264_main(argc, argv);
+}
+#endif
