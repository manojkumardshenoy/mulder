*** libavutil/mem.c.old	Wed Apr  1 18:35:44 2009
--- libavutil/mem.c	Wed Apr  1 18:35:44 2009
***************
*** 46,132 ****
  
  void *av_malloc(unsigned int size)
  {
!     void *ptr = NULL;
! #if CONFIG_MEMALIGN_HACK
!     long diff;
! #endif
  
!     /* let's disallow possible ambiguous cases */
!     if(size > (INT_MAX-16) )
!         return NULL;
! 
! #if CONFIG_MEMALIGN_HACK
!     ptr = malloc(size+16);
!     if(!ptr)
!         return ptr;
!     diff= ((-(long)ptr - 1)&15) + 1;
!     ptr = (char*)ptr + diff;
!     ((char*)ptr)[-1]= diff;
! #elif HAVE_POSIX_MEMALIGN
!     if (posix_memalign(&ptr,16,size))
!         ptr = NULL;
! #elif HAVE_MEMALIGN
!     ptr = memalign(16,size);
!     /* Why 64?
!        Indeed, we should align it:
!          on 4 for 386
!          on 16 for 486
!          on 32 for 586, PPro - K6-III
!          on 64 for K7 (maybe for P3 too).
!        Because L1 and L2 caches are aligned on those values.
!        But I don't want to code such logic here!
!      */
!      /* Why 16?
!         Because some CPUs need alignment, for example SSE2 on P4, & most RISC CPUs
!         it will just trigger an exception and the unaligned load will be done in the
!         exception handler or it will just segfault (SSE2 on P4).
!         Why not larger? Because I did not see a difference in benchmarks ...
!      */
!      /* benchmarks with P3
!         memalign(64)+1          3071,3051,3032
!         memalign(64)+2          3051,3032,3041
!         memalign(64)+4          2911,2896,2915
!         memalign(64)+8          2545,2554,2550
!         memalign(64)+16         2543,2572,2563
!         memalign(64)+32         2546,2545,2571
!         memalign(64)+64         2570,2533,2558
  
!         BTW, malloc seems to do 8-byte alignment by default here.
!      */
! #else
!     ptr = malloc(size);
  #endif
-     return ptr;
  }
  
! void *av_realloc(void *ptr, unsigned int size)
  {
! #if CONFIG_MEMALIGN_HACK
!     int diff;
! #endif
  
!     /* let's disallow possible ambiguous cases */
!     if(size > (INT_MAX-16) )
!         return NULL;
! 
! #if CONFIG_MEMALIGN_HACK
!     //FIXME this isn't aligned correctly, though it probably isn't needed
!     if(!ptr) return av_malloc(size);
!     diff= ((char*)ptr)[-1];
!     return (char*)realloc((char*)ptr - diff, size + diff) + diff;
  #else
!     return realloc(ptr, size);
  #endif
  }
  
  void av_free(void *ptr)
  {
!     /* XXX: this test should not be needed on most libcs */
!     if (ptr)
! #if CONFIG_MEMALIGN_HACK
!         free((char*)ptr - ((char*)ptr)[-1]);
  #else
!         free(ptr);
  #endif
  }
  
--- 46,155 ----
  
  void *av_malloc(unsigned int size)
  {
! #ifdef __APPLE__
! 	return malloc(size);
! #else
! 	char *c;
  
! 	uint64_t l, lorg;
! 	uint32_t *backdoor;
  
! 	l = (uint64_t)malloc(size + 32);
! 
! 	// Get next boundary
! 	lorg = l;
! 	l = (l + 15) & 0xfffffffffffffff0LL;
! 	l += 16;
! 	c = (char*)l;
! 	backdoor = (uint32_t*)(c - 8);
! 	*backdoor = (0xdead << 16) + l - lorg;
! 	backdoor[1] = size;
! 
! 	return c;
  #endif
  }
  
! void *av_realloc(void *ptr, unsigned int newsize)
  {
! #ifdef __APPLE__
! 	if (!ptr)
! 		return av_malloc(newsize);
! 
! 	if (!newsize)
! 	{
! 		av_free(ptr);
! 		return NULL;
! 	}
  
! 	return realloc(ptr, newsize);
  #else
! 	void *nalloc;
! 
! 	if (!ptr)
! 		return av_malloc(newsize);
! 
! 	if (!newsize) 
! 	{
! 		av_free(ptr);
! 		return NULL;
! 	}
! 
! 	// now we either shrink them or expand them
! 	// in case of shrink, we do nothing
! 	// in case of expand we have to copy
! 	// Do copy everytime (slower)
! 	uint32_t *backdoor;
! 	uint32_t size, offset;
! 	char *c = (char*)ptr;
! 
! 	backdoor = (uint32_t*)ptr;
! 	backdoor -= 2;
! 
! 	assert(((*backdoor) >> 16) == 0xdead);
! 
! 	offset = backdoor[0] & 0xffff;
! 	size = backdoor[1];
! 
! 	if(size >= newsize) // do nothing
! 		return ptr;
! 
! 	// Allocate a new one
! 	nalloc = av_malloc(newsize);
! 	memcpy(nalloc, ptr, size);
! 	av_free(ptr);
! 
! 	return nalloc;
  #endif
  }
  
  void av_free(void *ptr)
  {
! #ifdef __APPLE__
! 	if (!ptr)
! 		return;
! 
! 	free(ptr);
  #else
! 	uint32_t *backdoor;
! 	uint32_t size, offset;
! 	char *c = (char*)ptr;
! 
! 	if (!ptr)
! 		return;
! 
! 	backdoor = (uint32_t*)ptr;
! 	backdoor -= 2;
! 
! 	if (*backdoor == 0xbeefbeef)
! 		assert(0);
! 
! 	assert(((*backdoor) >> 16) == 0xdead);
! 
! 	offset = backdoor[0] & 0xffff;
! 	size = backdoor[1];
! 	*backdoor = 0xbeefbeef; // Scratch sig
! 
! 	free(c - offset);
  #endif
  }
  
